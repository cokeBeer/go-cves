# CVE-2022-32190 path traversal

## 漏洞信息
- 漏洞类型：目录遍历
- 漏洞版本：Go < 1.19.1 & 1.18.6
- 漏洞简介：目录拼接不正确导致可能的目录遍历

## 漏洞分析
首先看[issue]()中给出的两种绕过方式\
第一种情形，当`url.JoinPath`的首个参数末尾不是`/`时，会导致正则化失败
```go
// case 1
fmt.Println(url.JoinPath("https://go.dev", "../x"))  // https://go.dev/../x
fmt.Println(url.JoinPath("https://go.dev/", "../x")) // https://go.dev/x
```
第二种情形，在上面修复的基础上，出现了一个新的绕过\
当后续参数的开头部分存在空白字符或者其他特殊字符时，仍然会导致正则化失败
```go
// case 2
url.JoinPath("https://go.dev", "./../../x") // https://go.dev/../../x
url.JoinPath("https://go.dev", "..;/../../../../../x") // https://go.dev/../../../../x
url.JoinPath("https://go.dev", " ../../../../../../x") // https://go.dev/../../../../x

// 预期的情形
url.JoinPath("https://go.dev", "../.././x") // https://go.dev/x
```

## 修复方式
首先看`url.JoinPath`的实现，它将第一个参数解析为URL类型的对象，然后在此基础上调用`JoinPath`方法
```go
// JoinPath returns a URL string with the provided path elements joined to
// the existing path of base and the resulting path cleaned of any ./ or ../ elements.
func JoinPath(base string, elem ...string) (result string, err error) {
	url, err := Parse(base)
	if err != nil {
		return
	}
	result = url.JoinPath(elem...).String()
	return
}
```
我们知道`path.Join`这个方法在输入的第一个参数为开头不为`/`时，或者说不代表一个绝对目录，而是代表一个相对目录时，不会自动处理掉后续参数中所有的`../`
``` go
path.Join("", "../../../../x") // ../../../../x
path.Join("/","../../../../x") // /x
```
那么在这里之前的版本中解析URL获取的path为相对路径时，直接进行`path.Join`就会导致后续参数中所有的`../`逃逸，导致目录遍历\
参考修复的[PR](https://go-review.googlesource.com/c/go/+/422715)，第一个版本修复后的代码如下\
注意到如果`path`（也就是`elem[0]`）为相对路径时，仅在存在开头为`../`的其他`elem`时，才进行特殊处理，因此导致修复的绕过
```go
// JoinPath returns a new URL with the provided path elements joined to
// any existing path and the resulting path cleaned of any ./ or ../ elements.
// Any sequences of multiple / characters will be reduced to a single /.
func (u *URL) JoinPath(elem ...string) *URL {
	url := *u
	if len(elem) > 0 {
		elem = append([]string{u.EscapedPath()}, elem...)
		p := path.Join(elem...)

		// fix issue https://golang.org/issue/54385
		if elem[0] == "" {
			for k := range elem {
				if strings.HasPrefix(elem[k], "../") {
					p = path.Join(u.EscapedPath(), path.Clean("/"+path.Join(elem...)))
					break
				}
			}
		}
		// path.Join will remove any trailing slashes.
		// Preserve at least one.
		if strings.HasSuffix(elem[len(elem)-1], "/") && !strings.HasSuffix(p, "/") {
			p += "/"
		}
		url.setPath(p)
	}
	return &url
}
```
参考第二次修复的[PR](https://go-review.googlesource.com/c/go/+/423514/4/src/net/url/url.go)，最后修复的代码如下\
只要`path`是相对目录，就添加一个`/`然后调用`path.Join`
```go
// JoinPath returns a new URL with the provided path elements joined to
// any existing path and the resulting path cleaned of any ./ or ../ elements.
// Any sequences of multiple / characters will be reduced to a single /.
func (u *URL) JoinPath(elem ...string) *URL {
	elem = append([]string{u.EscapedPath()}, elem...)
	var p string
	if !strings.HasPrefix(elem[0], "/") {
		// Return a relative path if u is relative,
		// but ensure that it contains no ../ elements.
		elem[0] = "/" + elem[0]
		p = path.Join(elem...)[1:]
	} else {
		p = path.Join(elem...)
	}
	// path.Join will remove any trailing slashes.
	// Preserve at least one.
	if strings.HasSuffix(elem[len(elem)-1], "/") && !strings.HasSuffix(p, "/") {
		p += "/"
	}
	url := *u
	url.setPath(p)
	return &url
}
```

## 参考链接
- https://github.com/golang/go/issues/54385